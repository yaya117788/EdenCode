# 위험균형 포트폴리오
''' 특정 자산이 포트폴리오의 위험을 대부분 차지하는 문제를 막고, 모든 자산이 동일한 위험기여도를 가지는 포트폴리오가 위험균형 포트폴리오 혹은
동일 위험기여도 포트폴리오라고 부른다.'''
''' 수식은 다음과 같다.RC1=RC2=⋯=RCn 으로 나타낸다. 각 RC는 위 RC 식으로 분해가능'''




''' 포트폴리오를 구성하는 자산들의 전체위험의 관계를 이해하기 위해서는, 먼저 함계위험기여도(MRC: mariginal risk contribution)
과 위험기여도(RC: risk contribution)에 대해 알아야한다. 

한계위험기여도는 특정자산의 비중을 한단위 
증가시켰을때 전체 포트폴리오의 위험의 증가를 나타내는 단위로서 , 수학의 편미분과 같은 개념이다. 
MRC(i)=∂σ(p)/∂w(i) 로 표현할수 있다. 그리고 
√f′(x)=f′(x)/2√f(x) 인 사실을 이용하면, 한계위험기여도를 풀 수 있다. 결과적으로 분자는 분산-공분산 행렬과 각 자산의 비중의 곱,
분모는 포트폴리오의 표준편차 형태로 나타낸다.
∂σ(p)/∂w=Ωw/√w′Ωw 이렇게 표현된다.

위험기여도는 특정 자산이 포트폴리오 내 차지하는 위험의 비중이다. 예를 들어 한계위험 기여도가 큰 자산도 포트폴리오내 비중이 작으면 포트폴리오내 차지하는 위험의 비중은 작을 것이다. 역도 성립!
결과적으로 한계위험기여도와 위험기여도는 연관이 있고 위험기여도는 이렇게 구해진다.
RC(i)=(∂σ(p)/∂w(i))×wi
'''


# 한계위험기여도, 위험기여도의 코드화
''' 먼저 포트폴리오 비중인 w와 분산-공분산행렬인 covmat을 이용해 한계위험기여도를 계산한다. 그 후 비중 w를 곱해
위험기여도를 계산해준후 합계가 1이되도록 표준화시켜준다.'''
get_RC = function(w, covmat) {
  port_vol = t(w) %*% covmat %*% w
  ## 먼저 포트폴리오의 분산형태를 구해준다. t(w)는 미분
  port_std = sqrt(port_vol)
  ## 그것을 루트를 씌어서 표준편차 = 변동성 형태로 나타낸다 
  MRC = (covmat %*% w) / as.numeric(port_std)
  
  ## 한계위험기여도(MRC)를 계산한다. 분산공분산행렬 X 비중 / 변동성
  RC = MRC * w
  ## MRC에 비중을 다시 곱해서 위험기여도를 구한다.
  RC = c(RC / sum(RC))
  ## 최대 1로 표준화를 시킨다.
  return(RC)
}


# 실습

# 1. 주식 60%와 채권 40%의 포트폴리오의 위험기여도
''' 자산 배분에서 가장많이 사용되는 투자방법은 주식에 60%, 채권에 40% 가량의 비율로 투자하는 것이다.
둘의 상관관계가 낮아 분산효과가 있고, 장기적으로 주식이 채권에 비해 수익률이 높다는점을 감안해 합리적인 방법으로 보인다.
하지만 눈에 보이는 비중이 60대 40이라도, 각 자산이 가지고 있는 RC는 전혀다른 비중을 가지고 있다.'
ret_stock_bond = rets[, c(1, 5)]
## 첫번째 각 자산별 수익률을 끌어온것을 이용한다. 1번째는 미국주식, 5번째는 미국장기채 의미
cov_stock_bond = cov(ret_stock_bond)
## 두 자산을 이용해 분산-공분산 행렬을 만들어준다.
RC_stock_bond = get_RC(c(0.6, 0.4), cov_stock_bond)
## get_RC함수를 통해 자산별 위험기여도를 계산해준다. 투자비중을 60대 40으로 설정해본다.
RC_stock_bond = round(RC_stock_bond, 4)

print(RC_stock_bond)
'''주식 장기채가 가지는 위험기요도는 각각 97.56%, 2.44%로 투자비중과는 전혀다른 위험기여도를 가진다.
주식이 포트폴리오 위험의 대부분을 차지하고있다.'''


# 2. rp() 함수를 이용한 최적화
''' 모든 자산이 동일한 위험기여도를 가지는 포트폴리오인 "위험균형 포트폴리오"는 
역시 slsqp()나 optimalPortfolio() 함수를 이용해 구현할수 있으나 간혹 최적화된 값을 찾지 못할때가 존재한다.
반면 cccp 패키지의 rp() 함수를 이용하면 매우 정확하게 위험균형 pot를 구성하는 비중을 계산할 수 있다.'''

library(cccp)

opt = rp(x0 = rep(0.1, 10),
         P = covmat,
         mrc = rep(0.1, 10))
''' X0는 최적화를 위한 초기입력값으로 동일비중인 10%씩을 입력
    P는 분산- 공분산 행렬을 입력
    mrc는 목표로 하는 각 자산별 위험기여도 값이며, 위험균형은 모든 자산위험기여도가 동일해야하므로 10%씩 입력한다.'''


w = getx(opt) %>% drop()
## getx 함수를 통해 해를 추출할 수 있고, drop() 함수로 벡터 형태로 변환한다.
w = (w / sum(w)) %>%
  round(., 4) %>%
  setNames(colnames(rets))
## 비중의 합이 1이 되기위해 비중들의 합으로 나눠준다. 표준화
print(w)
''' 각 자산의 비중이 계산된다.'''

get_RC(w, covmat)
# get_RC 함수를 통해 위험기여도를 확인해보면 거의 동일한 위험기여도를 가지는 것을 알 수 있다.


# 3. 위험예산 포트폴리오
''' 모든 자산이 동일한 위험균형 포트롤리오가 아니라 자산별로 다른 위험기여도를 가지는 POT를 구성해야할 수 있는데,
이를 "위험예산 포트폴리오"라고 한다. rp()함수를 통해 구할 수 있으며 위험균형 pot는 위험예산 pot의 특수형태일 뿐이다.'''

## 각 자산별 위험예산을 다르게 설정해본다.
library(cccp)

opt = rp(x0 = rep(0.1, 10),
         P = covmat,
         mrc = c(0.15, 0.15, 0.15, 0.15, 0.10,
                 0.10, 0.05, 0.05, 0.05, 0.05))
# mrc부분을 각각의 원하는 위험기여도 비율을 가져가본다.

w = getx(opt) %>% drop()
w = (w / sum(w)) %>%
  round(., 4) %>%
  setNames(colnames(rets))

print(w)
# 각각 자산별로 투자비중을 먼저 구해본다. 아마 위험기여도는 위에 설정했던 정도로 나누어 졌을 것이다.

get_RC(w, covmat)
